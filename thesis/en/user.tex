\chapter{User Documentation}
\label{ch:user}

This chapter serves as a practical guide for users working with the Qubitkit platform. Whether you are a student exploring quantum algorithms for the first time, an educator demonstrating quantum concepts in the classroom, or a researcher prototyping novel circuits, this documentation will guide you through the platform's capabilities. The chapter progresses from initial setup through circuit design to result interpretation, providing both step-by-step procedures and conceptual explanations of the platform's behavior.

The documentation assumes basic familiarity with quantum computing concepts such as qubits, quantum gates, and measurement. Users without this background may wish to consult introductory quantum computing resources before proceeding. However, the platform's visual interface is designed to make circuit experimentation accessible even to those still developing their quantum intuition.

\section{Accessing the Platform}
\label{sec:user:access}

The Qubitkit platform operates as a web application accessible through standard web browsers without local software installation. Users access the system by navigating to the deployed application URL or by setting up a local development environment as described in Section~\ref{sec:user:local-setup}.

\textbf{System Requirements:}
\begin{compactitem}
    \item Modern web browser (Chrome~\cite{chrome2024} 90+, Firefox~\cite{firefox2024} 88+, Safari~\cite{safari2024} 14+, Edge~\cite{edge2024} 90+)
    \item Stable internet connection (minimum 1 Mbps for WebSocket streaming)
    \item JavaScript~\cite{ecmascript2025} and cookies enabled
    \item Display resolution 1280×720 pixels or larger (recommended)
\end{compactitem}

\textbf{Browser Configuration:} For optimal performance, enable third-party cookies for OAuth~\cite{rfc6749} providers, WebSocket~\cite{rfc6455} connections for real-time job monitoring, and LocalStorage for session persistence. Pop-up blockers may interfere with Microsoft Azure AD authentication—temporarily disable them if authentication fails. The platform supports English, German, and Hungarian interface languages through i18next~\cite{i18next2024} internationalization framework.

\section{Local Development Setup}
\label{sec:user:local-setup}

Most users will access Qubitkit through a deployed web instance without requiring local installation. However, developers and contributors extending the platform will need to run it locally. This section guides you through setting up both frontend and backend components in a development environment.

The complete source code is publicly available at \url{https://github.com/alfaarizi/qubit}, licensed under Apache-2.0 to encourage community contributions and research reproducibility.

The setup process requires approximately 20-30 minutes for users with Node.js~\cite{nodejs2024} 18+ and Python~\cite{pythondocs2024} 3.8+ already installed. The platform architecture separates into frontend and backend components, each requiring independent setup and configuration. The primary challenge involves configuring environment variables correctly—particularly the MongoDB Atlas connection string and SQUANDER SSH credentials. We recommend following the subsections in order, verifying each component works before proceeding to the next.

\subsection{Frontend Setup}
\label{subsec:user:frontend-setup}

The frontend application resides in the \texttt{frontend/} directory. Navigate to this directory and install dependencies:

\begin{verbatim}
cd frontend
npm install
\end{verbatim}

The \texttt{npm install} command reads \texttt{package.json} and installs all required packages including React 19, TypeScript, Vite 7, Zustand, Monaco Editor, and visualization libraries. Dependencies download to \texttt{node\_modules/} directory.

Create a \texttt{.env.local} file in the frontend directory with the following environment variables:

\begin{verbatim}
VITE_API_BASE_URL=http://localhost:8000/api/v1
VITE_GOOGLE_CLIENT_ID=<your-google-oauth-client-id>
VITE_MICROSOFT_CLIENT_ID=<your-microsoft-azure-ad-client-id>
VITE_DEV_PORT=3000
\end{verbatim}

\textbf{Environment Variable Descriptions:}

\begin{description}
    \item[VITE\_API\_BASE\_URL] Backend API endpoint base URL. Must match the backend server address including the \texttt{/api/v1} path prefix.
    \item[VITE\_DEV\_PORT] Development server port (optional). Defaults to 5173 if not specified. Common alternative: 3000.
    \item[VITE\_GOOGLE\_CLIENT\_ID] OAuth 2.0 client ID from Google Cloud Console (optional for development).
    \item[VITE\_MICROSOFT\_CLIENT\_ID] Azure AD application client ID from Azure Portal (optional for development).
\end{description}

OAuth client IDs can be left empty during development if OAuth authentication is not required; email verification authentication will continue to function. The \texttt{VITE\_DEV\_PORT} variable allows customization of the development server port to avoid conflicts with other local services.

Launch the development server:

\begin{verbatim}
npm run dev
\end{verbatim}

Vite serves the application at \texttt{http://localhost:\{VITE\_DEV\_PORT\}} (defaults to \texttt{http://localhost:5173}) with hot module replacement enabled. Code changes trigger automatic browser refresh without full page reload.

\subsection{Backend Setup}
\label{subsec:user:backend-setup}

The backend application resides in the \texttt{backend/} directory. The project uses \texttt{pyproject.toml} for dependency management and packaging. Navigate to the backend directory and install the package in editable mode:

\begin{verbatim}
cd backend
python -m pip install -e .
\end{verbatim}

The editable installation (\texttt{-e} flag) allows code modifications to take effect immediately without reinstallation. The command installs FastAPI, Uvicorn, Paramiko, PyMongo, python-jose, and other dependencies specified in \texttt{pyproject.toml}.

\subsection{Environment Configuration}
\label{subsec:user:env-config}

Create a \texttt{.env} file in the backend directory with required environment variables. The platform behavior adapts based on these settings, particularly the \texttt{DEBUG} flag which controls development versus production mode.

\textbf{Development Environment Variables:}

\begin{verbatim}
DEBUG=True
HOST=0.0.0.0
PORT=8000
FRONTEND_URL=http://localhost:3000

MONGODB_URL=<your-mongodb-atlas-connection-string>
MONGODB_DATABASE=qubitkit

SECRET_KEY=<random-secret-key-for-jwt-signing>
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

GOOGLE_CLIENT_ID=<your-google-oauth-client-id>
MICROSOFT_CLIENT_ID=<your-microsoft-azure-ad-client-id>

RESEND_API_KEY=<resend-api-key-for-email>
EMAIL_FROM=QubitKit <noreply@qubitkit.com>

SQUANDER_SSH_HOST=<squander-server-hostname>
SQUANDER_SSH_USER=<squander-server-username>
SQUANDER_SSH_PATH=<path-to-squander-on-server>
SSH_KEY_PATH=<path-to-ssh-private-key>
SSH_TIMEOUT=30
SQUANDER_EXEC_TIMEOUT=300
\end{verbatim}

\textbf{Key Environment Variables:}

\begin{description}
    \item[DEBUG] When \texttt{True}, enables auto-reload on code changes, verbose logging, and development-specific error messages. Set to \texttt{False} for production deployment.
    \item[FRONTEND\_URL] CORS origin whitelist. Must match the URL serving the frontend application (including port number).
    \item[MONGODB\_URL] MongoDB Atlas connection string (see Section~\ref{subsec:user:mongodb-setup}).
    \item[SECRET\_KEY] Random string used for JWT token signing. Generate with: \texttt{openssl rand -hex 32}
    \item[SQUANDER\_SSH\_*] SSH credentials for connecting to remote SQUANDER server. Required for circuit partitioning and simulation.
\end{description}

\subsection{MongoDB Atlas Configuration}
\label{subsec:user:mongodb-setup}

The platform uses MongoDB Atlas, a cloud-hosted database service, eliminating the need for local MongoDB installation. To configure database access:

\begin{enumerate}
    \item Sign up for a free MongoDB Atlas account at \texttt{https://www.mongodb.com/cloud/atlas/register}
    \item Create a new cluster (M0 Sandbox tier provides free 512MB storage sufficient for development)
    \item Configure network access to allow connections from your development machine IP address (or use \texttt{0.0.0.0/0} for development only)
    \item Create a database user with read/write permissions through Database Access settings
    \item Navigate to cluster overview and click "Connect" button
    \item Select "Connect your application" and copy the connection string
    \item Replace \texttt{<password>} placeholder with the database user password
    \item Replace \texttt{<dbname>} with \texttt{qubitkit} or desired database name
    \item Add complete connection string to backend \texttt{.env} file as \texttt{MONGODB\_URL}
\end{enumerate}

The connection string format follows:

\begin{verbatim}
mongodb+srv://<username>:<password>@cluster0.xxxxx.mongodb.net/
qubitkit?retryWrites=true&w=majority
\end{verbatim}

The backend establishes connections using Motor, an async MongoDB driver compatible with FastAPI's asyncio event loop. The \texttt{MONGODB\_DATABASE} environment variable specifies which database within the cluster to use.

\subsection{Launching the Backend Server}
\label{subsec:user:backend-launch}

The backend provides a convenience \texttt{serve} command defined in \texttt{pyproject.toml} that automatically adapts behavior based on the \texttt{DEBUG} environment variable:

\begin{verbatim}
serve
\end{verbatim}

When \texttt{DEBUG=True} (development mode), the server launches with:
\begin{compactitem}
    \item Auto-reload on code changes (\texttt{--reload})
    \item Verbose logging output
    \item Detailed error messages with stack traces
\end{compactitem}

When \texttt{DEBUG=False} (production mode), the server launches with:
\begin{compactitem}
    \item No auto-reload for stability
    \item Structured JSON logging
    \item Minimal error disclosure
\end{compactitem}

Alternatively, launch the server directly with Uvicorn for explicit control:

\begin{verbatim}
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
\end{verbatim}

The \texttt{--reload} flag monitors source files for changes and automatically restarts the server. The backend serves API endpoints at \texttt{http://localhost:8000} with WebSocket support at the same port.

\subsection{SQUANDER Server Access}
\label{subsec:user:squander-access}

Circuit partitioning and simulation require SSH access to a server with SQUANDER installed. Development environments can:

\begin{compactitem}
    \item Request access credentials to the shared SQUANDER development server
    \item Install SQUANDER locally following instructions at \texttt{https://github.com/rakytap/sequential-quantum-gate-decomposer}
    \item Configure SSH credentials in backend \texttt{.env} file with \texttt{SQUANDER\_SSH\_*} variables
\end{compactitem}

SQUANDER installation requires C++ compiler, BLAS/LAPACK libraries, and Python development headers. The platform's backend handles all SQUANDER interaction via Paramiko SSH client; frontend developers do not require direct SQUANDER access.

If using SSH key-based authentication (recommended), generate an SSH key pair and specify the private key path in \texttt{SSH\_KEY\_PATH}. The public key must be added to the SQUANDER server's \texttt{~/.ssh/authorized\_keys} file.

\subsection{Verifying Setup}
\label{subsec:user:verify-setup}

With both frontend and backend running:

\begin{enumerate}
    \item Navigate to \texttt{http://localhost:\{VITE\_DEV\_PORT\}} in browser (default: \texttt{http://localhost:5173})
    \item Verify authentication page loads correctly without console errors
    \item Test authentication using email verification method (requires \texttt{RESEND\_API\_KEY})
    \item Create a test project and circuit
    \item Verify circuit composer interface renders properly
    \item Place a few gates and test undo/redo functionality
    \item Check backend terminal logs for successful MongoDB connection message
    \item Verify WebSocket connection establishes (check Network tab in browser DevTools~\cite{chromedevtools2024})
\end{enumerate}

Common setup issues include:

\begin{compactitem}
    \item \textbf{MongoDB connection failures}: Check IP whitelist in Atlas Network Access settings
    \item \textbf{CORS errors}: Verify \texttt{FRONTEND\_URL} in backend .env matches frontend development server URL exactly, including port number
    \item \textbf{WebSocket connection failures}: Ensure backend server is accessible at the URL specified in \texttt{VITE\_API\_BASE\_URL}
    \item \textbf{OAuth authentication failures}: Verify client IDs match those in Google Cloud Console and Azure Portal, and callback URLs are configured correctly
\end{compactitem}

\section{Getting Started}
\label{sec:user:getting-started}

\subsection{Home Landing Page}
\label{subsec:user:home}

The home landing page (Figure~\ref{fig:home-interface}) serves as the entry point to the platform, accessible without authentication. It features a hero banner with introductory content, feature highlights showcasing the platform's capabilities, SQUANDER integration information, and a prominent "Get Started" button that navigates users to the registration page.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/pages/home_page}}
    \caption{Home landing page with hero banner, feature cards, SQUANDER integration section, and platform capabilities}
    \label{fig:home-interface}
\end{figure}

\subsection{Registration and Authentication}
\label{subsec:user:registration}

To access the platform's features, users must authenticate. Clicking the "Get Started" button navigates to the login page. Authentication serves two purposes: it secures access to private projects and circuits, and it enables the backend to track job submissions and results for each user. The platform supports three authentication methods to accommodate different user preferences and institutional requirements. Users affiliated with Google Workspace or Microsoft 365 organizations can leverage their existing credentials, while independent users can authenticate via email without creating additional accounts.

Users access the platform through these authentication methods shown in Figure~\ref{fig:login-interface}. Each method creates a user account in the MongoDB database with encrypted credential storage.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/pages/login_page}}
    \caption{Login interface showing Google OAuth, Microsoft Azure AD, and email verification authentication options}
    \label{fig:login-interface}
\end{figure}

\textbf{Google OAuth 2.0:} Redirects to Google's authentication server where users authorize access to their email and profile.

\textbf{Microsoft Azure AD:} Initiates MSAL authentication flow for Microsoft 365 accounts, fetching profile information including profile pictures from Microsoft Graph API.

\textbf{Email Verification:} Users receive a 5-digit code valid for 5 minutes. This method requires no third-party accounts and works independently of organizational credentials.

All methods create or retrieve user accounts with encrypted credential storage. Upon successful authentication, the backend issues JWT access tokens (30-minute expiry) and refresh tokens (7-day expiry). Sessions remain active for 7 days or until explicit logout. The platform automatically refreshes expired access tokens in the background, preventing interruptions during circuit execution. When OAuth emails match existing accounts, the system links providers to avoid duplicates.

\subsection{User Profile Management}
\label{subsec:user:profile}

After authentication, users can access their profile page (Figure~\ref{fig:profile-interface}) to view and manage account information. The profile interface displays personal information including first name, last name, email address, and user ID.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/pages/profile_page}}
    \caption{User profile page showing personal information and account settings}
    \label{fig:profile-interface}
\end{figure}

\section{Project and Circuit Management}
\label{sec:user:projects}

\subsection{Project Organization}
\label{subsec:user:project-organization}

After authentication, users land on the project list page (Figure~\ref{fig:project-interface}) which displays all user projects in either grid or list view. Project cards show the project name, description, creation date, and a thumbnail preview of the project's circuits. The interface includes a sidebar with filter options (All Projects, Your Projects, Shared with you, Archived, Trashed) and a search bar for finding specific projects.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/pages/project_page}}
    \caption{Project list interface displaying user projects in grid view with filters, search, and management options}
    \label{fig:project-interface}
\end{figure}

Creating a new project requires a project name and optional description. The system generates a unique project ID and initializes an empty circuits array in the MongoDB Projects collection. Users can rename, duplicate, or delete projects through the dropdown menu accessed via the ellipsis icon on each project card.

\subsection{Circuit Composer and Tab Management}
\label{subsec:user:circuit-management}

Selecting a project opens the composer workspace (Figure~\ref{fig:composer-interface}), where users design and manage quantum circuits. The composer interface supports multiple circuits within a single project through a tabbed layout in the toolbar. Each tab represents an independent circuit with its own gate configuration, quantum state, and undo history. Tabs are draggable, allowing users to reorder circuits horizontally.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/pages/composer_page}}
    \caption{Circuit composer interface showing multiple circuit tabs, gate palette (left), canvas (center), and inspector panel (right)}
    \label{fig:composer-interface}
\end{figure}

Users create new circuits by clicking the "+" button in the tab bar. Each circuit initializes with a default name following the pattern "Circuit 1", "Circuit 2", etc., a unique circuit ID, and an empty gate configuration. Circuit metadata includes:

\begin{compactitem}
    \item Number of qubits (default: 2, adjustable 1-10)
    \item Placed gates array (initially empty)
    \item Measurement configuration (default: all qubits measured)
    \item Simulation results (populated after execution)
    \item Undo/redo history (maintained per circuit)
\end{compactitem}

Deleting a circuit tab removes it from the project's circuits array and clears associated undo history from localStorage. If a circuit has running jobs (pending or executing), the system prompts the user to confirm closure, warning that execution will be aborted. Deletion is permanent and not reversible through undo operations.

\section{Circuit Composition}
\label{sec:user:composition}

With a circuit tab open, users can begin designing quantum circuits. The composer interface provides two modes of interaction: visual drag-and-drop gate placement and direct QASM code editing. Both modes maintain synchronized representations of the circuit, allowing users to switch between approaches as needed. This section explains gate placement mechanics, editing operations, and advanced features like circuit grouping and temporal undo/redo.

\subsection{Circuit Composer Interface}
\label{subsec:user:composer-interface}

The circuit composer (Figure~\ref{fig:composer-interface}) presents an interactive SVG canvas rendered with D3.js. The interface consists of four primary regions:

\begin{description}
    \item[Gate Palette] Left panel containing draggable gate elements: universal gates (U1, U2, U3), Pauli gates (X, Y, Z), phase gates (S, S†, T), Hadamard (H), rotation gates (RX, RY, RZ, R), square root gates (SX), two-qubit gates (CH, CNOT, CZ, CP, CRX, CRY, SWAP), and multi-qubit gates (CCX/Toffoli)
    \item[Circuit Canvas] Center region displaying horizontal qubit wires with placed gates at discrete depth positions
    \item[Visualization Panel] Right panel showing real-time quantum state visualizations updated as gates are placed
    \item[Control Bar] Top toolbar with qubit count controls, undo/redo buttons, QASM editor toggle, and execution controls
\end{description}

Qubit wires are rendered as horizontal lines spaced 60 pixels apart vertically. Gate depth positions appear as vertical columns spaced 80 pixels apart horizontally. The canvas supports zoom and pan operations via mouse wheel and drag gestures.

\subsection{Gate Placement}
\label{subsec:user:gate-placement}

Gate placement occurs through drag-and-drop interaction using native HTML5~\cite{html5standard} drag-and-drop events. The workflow proceeds as follows:

\begin{enumerate}
    \item User drags gate from palette onto canvas
    \item Drag sensor detects mouse position and snaps to nearest grid intersection (qubit wire and depth column)
    \item If an existing gate occupies the target position, it automatically shifts to the right along with all subsequent gates in that depth
    \item Gate placement adds to \texttt{placedGates} array with properties:
    \begin{compactitem}
        \item \texttt{id}: Unique UUID
        \item \texttt{type}: Gate name (e.g., "H", "CNOT")
        \item \texttt{qubit}: Target qubit index (0-based)
        \item \texttt{depth}: Horizontal position (0-based column)
        \item \texttt{params}: Rotation angles for parameterized gates
        \item \texttt{parents}: Array of gate UUIDs that must execute before this gate
        \item \texttt{children}: Array of gate UUIDs that execute after this gate
    \end{compactitem}
    \item Zustand store update triggers React re-render and D3 SVG update
    \item Zundo middleware captures state change in undo history (up to 50 states per circuit)
\end{enumerate}

For multi-qubit gates like CNOT, the placement interface displays a dialog requesting control and target qubit selection. The gate renders with a vertical line connecting control qubit (filled circle) to target qubit (open circle plus sign).

\subsection{Gate Editing and Deletion}
\label{subsec:user:gate-editing}

Right-clicking a placed gate opens a context menu with three options:

\begin{compactitem}
    \item \textbf{View Info}: Displays gate's unitary matrix representation and basic properties
    \item \textbf{Edit Gate}: Opens a dialog to modify the gate's target qubit(s). For multi-qubit gates, users can also reassign control qubits. For parameterized gates (rotation gates like Rx, Ry, Rz), the dialog includes input fields for rotation angles in radians or degrees
    \item \textbf{Delete Gate}: Removes gate from circuit and updates parent/child dependency connections
\end{compactitem}

Alternatively, delete operations support drag-to-delete behavior: dragging a gate back to the palette removes it from the circuit. Both deletion methods are captured in undo history and reversible via keyboard shortcuts (Section~\ref{subsec:user:keyboard}).

\subsection{Circuit Grouping}
\label{subsec:user:grouping}

Users can group multiple gates into a nested circuit structure, creating reusable subcircuits. To create a group:

\begin{enumerate}
    \item Select multiple gates using Shift+Click for individual selection or drag a selection box around gates (Figure~\ref{fig:gates-selected})
    \item Right-click on the selected gates to open the context menu
    \item Choose \textbf{Group} to open a dialog where you can enter a name for the circuit and select a color for visual identification, or \textbf{Delete} to remove all selected gates
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/miscellaneous/gates_selected}}
    \caption{Multiple gates selected using Shift+Click, highlighted with selection indicators before grouping}
    \label{fig:gates-selected}
\end{figure}

After confirming the group creation, the selected gates collapse into a single colored rectangle on the canvas, displaying the custom name you entered (Figure~\ref{fig:grouped-circuit}). The platform recalculates gate positions inside the group relative to where the group starts, and updates dependency connections so other gates correctly reference the group as a unit.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/miscellaneous/gates_grouped}}
    \caption{Circuit after grouping showing the gates collapsed into a colored rectangle with custom name}
    \label{fig:grouped-circuit}
\end{figure}

To ungroup a circuit, right-click on the grouped circuit rectangle and select \textbf{Ungroup}. This expands the group back into individual gates while maintaining their relative positions and connections to other gates. Right-clicking a grouped circuit also provides \textbf{View Info}, \textbf{Edit Circuit} (to rename or change the color), and \textbf{Delete Circuit} options.

\subsubsection{Flat and Nested Circuit Views}

When working with grouped circuits, the toolbar provides a "Show Nested Circuits" toggle that controls how much detail you see. By default, this toggle is off, showing a flat view where grouped circuits appear as simple colored rectangles (Figure~\ref{fig:flat-circuit}). This clean view helps you focus on the high-level circuit structure without visual clutter.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/miscellaneous/circuit_flat_view}}
    \caption{Flat circuit view showing only the top-level structure—grouped circuits appear as colored rectangles}
    \label{fig:flat-circuit}
\end{figure}

Enabling the toggle switches to nested view, which expands all grouped circuits to reveal their internal gates (Figure~\ref{fig:nested-circuit}). This expanded view applies recursively, so if you have groups within groups, all layers become visible. Nested view is useful when you need to inspect or debug the internal structure of grouped subcircuits, while flat view is better for understanding overall circuit organization.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/miscellaneous/circuit_nested_view}}
    \caption{Nested circuit view revealing the internal gate structure of all grouped subcircuits}
    \label{fig:nested-circuit}
\end{figure}

\subsection{QASM Code Editor}
\label{subsec:user:qasm}

The Monaco Editor integration (Figure~\ref{fig:qasm-editor}) provides syntax-highlighted QASM (Quantum Assembly Language) editing. Toggling to code view displays the circuit as OpenQASM 2.0 with full syntax highlighting and editing capabilities.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.4\textwidth]{docs/screenshots/components/qasm_editor}}
    \caption{Monaco Editor showing QASM code with syntax highlighting, line numbers, and auto-completion}
    \label{fig:qasm-editor}
\end{figure}

Edits to QASM code are parsed and reflected in the visual circuit upon saving. Invalid QASM syntax displays error messages with line numbers. The editor supports:

\begin{compactitem}
    \item Syntax highlighting for QASM keywords
    \item Auto-completion for gate names
    \item Error squiggles for invalid syntax
    \item Line numbers and folding
\end{compactitem}

Changes made in code view synchronize with the visual composer after validation. This bidirectional editing enables users to leverage whichever interface suits their workflow.

\subsection{Undo and Redo Operations}
\label{subsec:user:undo-redo}

The Zundo middleware maintains separate undo/redo stacks for each circuit, persisted to localStorage. State changes are captured when:

\begin{compactitem}
    \item Gates are added, deleted, or modified
    \item Qubit count changes
    \item Measurement configuration updates
    \item QASM code edits are saved
\end{compactitem}

Certain operations bypass history capture by setting the \texttt{skipHistory} flag:

\begin{compactitem}
    \item Initial circuit load from database
    \item Bulk updates during QASM import
    \item Programmatic state synchronization
\end{compactitem}

The history limit of 50 states per circuit prevents excessive localStorage usage. When the limit is exceeded, the oldest state is discarded from the \texttt{pastStates} array. Undo/redo operates independently for each circuit even when multiple circuit tabs are open simultaneously. Keyboard shortcuts for undo/redo operations are documented in Section~\ref{subsec:user:keyboard}.

\section{Circuit Execution}
\label{sec:user:execution}

\subsection{Partitioning and Execution Workflow}
\label{subsec:user:partition-exec}

From the user's perspective, circuit execution is straightforward: click "Partition Circuit," watch real-time progress updates, and view results when complete. Behind this simple interface, however, the platform orchestrates a complex distributed workflow involving SSH~\cite{rfc4254} connections to remote servers, file transfers, and WebSocket~\cite{rfc6455} streaming. This section explains both what users see and what occurs behind the scenes.

The platform executes quantum circuits by submitting partition jobs to the remote SQUANDER server. Circuit partitioning divides large quantum circuits into smaller subcircuits that can be simulated more efficiently. The workflow involves SSH-based connectivity with real-time WebSocket progress streaming.

\textbf{Job Submission:} Clicking "Partition Circuit" initiates the execution workflow. The frontend creates a partition job with the following metadata:

\begin{compactitem}
    \item Job ID (UUID)
    \item User ID (from JWT token)
    \item Circuit ID
    \item Partitioning strategy (Kahn's algorithm by default, or user-selected ILP/other strategies)
    \item Creation timestamp
    \item Status ("queued")
\end{compactitem}

The frontend establishes a WebSocket connection for real-time progress updates. The backend manages job execution using an SSH connection pool (maximum 5 concurrent connections). The workflow proceeds through eight phases: connecting, preparing, uploading, building, simulating, downloading, cleanup, and complete. Each phase broadcasts progress updates including phase name, progress percentage, and job identifiers. Connection pooling reuses SSH sessions to avoid repeated authentication overhead.

\subsection{Job Monitoring}
\label{subsec:user:job-monitoring}

The job monitoring interface (Figure~\ref{fig:job-monitoring}) displays real-time progress for all active jobs associated with the current user. Job cards show:

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/miscellaneous/job_monitoring}}
    \caption{Job monitoring panel showing active jobs with real-time progress updates}
    \label{fig:job-monitoring}
\end{figure}

\begin{compactitem}
    \item Circuit name and project
    \item Current phase and progress percentage
    \item Elapsed time and estimated time remaining
    \item Streaming output log (last 100 lines)
    \item Cancel button (sends cancellation signal via WebSocket)
\end{compactitem}

WebSocket messages use JSON~\cite{rfc7159} format. Example phase update message:

\begin{verbatim}
{
  "type": "phase",
  "phase": "building",
  "message": "Building and partitioning circuit...",
  "progress": 5,
  "job_id": "33e1c984-5479-4988-914f-8ce84500fa03",
  "circuit_id": "circuit-f737e90d-a94b-4aaf-9718-8569d8780fd3"
}
\end{verbatim}

Additional message types include \texttt{"log"} for detailed simulation logs, \texttt{"complete"} for successful completion, and \texttt{"error"} for failures.

The frontend \texttt{useJobManager} custom hook subscribes to these messages and updates the Zustand job store, triggering React component re-renders. Job state persists across page refreshes via localStorage snapshots.

\subsection{Error Handling}
\label{subsec:user:errors}

Execution errors fall into three categories:

\textbf{Validation Errors:} Detected before submission (e.g., empty circuit, unsupported gates). The frontend displays validation messages and prevents job submission.

\textbf{SSH Connection Errors:} Network failures, authentication failures, or connection pool exhaustion. These trigger automatic retry with exponential backoff (3 attempts, delays of 1s, 2s, 4s). Persistent failures return error status to user.

\textbf{Execution Errors:} SQUANDER process failures (e.g., insufficient memory, invalid circuit decomposition). The backend parses STDERR output for error messages and streams them to connected clients. Jobs transition to "error" status with diagnostic information.

Error notifications appear as toast messages using the Sonner library, positioned in the top-right corner of the interface. Users can click notifications to view full error details or dismiss them.

\section{Visualizing Execution Results}
\label{sec:user:visualization}

\subsection{Visualization Types}
\label{subsec:user:viz-types}

Understanding quantum states requires multiple perspectives. Since quantum states are complex-valued probability amplitudes, no single visualization captures all properties—measurement distributions show likely outcomes but hide phase information, while state vectors and density matrices reveal quantum structure but require careful interpretation.

Upon successful circuit execution, the visualization panel displays eight complementary visualization types that compare original and partitioned circuit results side by side. This enables direct assessment of partitioning fidelity through statistical metrics and visual comparisons across measurement distributions, state vectors, density matrices, and entanglement entropy.

\subsubsection{Circuit Fidelity Check}

The simulation results header (Figure~\ref{fig:viz-fidelity}) displays circuit fidelity alongside execution parameters including shot count, partitioning strategy, and maximum partition size. Fidelity $F = |\langle\psi_{\text{original}}|\psi_{\text{partitioned}}\rangle|^2$ quantifies how closely the partitioned circuit reproduces the original quantum state. The display uses color coding: green for fidelity $\geq 99\%$, blue for $95\%-99\%$, and orange for $< 95\%$.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/components/viz_fidelity}}
    \caption{Circuit fidelity metric and execution parameters}
    \label{fig:viz-fidelity}
\end{figure}

\subsubsection{Partition Viewer and Distribution}

The partition viewer provides two viewing modes: individual and sequential. The individual mode (Figure~\ref{fig:viz-partition}) displays the gate structure of a selected partition, while the sequential mode (Figure~\ref{fig:viz-partition-individual}) displays all partitions together as a unified circuit, with line boundaries indicating partition divisions.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/components/viz_partition_individual}}
    \caption{Individual partition view with gate structure}
    \label{fig:viz-partition}
\end{figure}

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/components/viz_partition}}
    \caption{Sequential partition view showing all partitions with boundaries}
    \label{fig:viz-partition-individual}
\end{figure}

Both modes include footer statistics displaying the gate count, qubit usage, and utilization percentage. The distribution histogram shows gate count per partition using color-coded bars: green ($\geq 85\%$ utilization), yellow ($70\%-85\%$), orange ($55\%-70\%$), and red ($< 55\%$).

\subsubsection{Partition Highlighting in Original Circuit}

Users can enable the "Show in Original Circuit" toggle to highlight the selected partition's gates in the main circuit composer (Figure~\ref{fig:gates-in-partition}), where gates are outlined with colored borders that match the partition color. This feature helps visualize how the original circuit has been divided across partitions.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/miscellaneous/gates_in_partition}}
    \caption{Original circuit with highlighted gates from selected partition}
    \label{fig:gates-in-partition}
\end{figure}

\subsubsection{Measurement and Probability Distributions}

Figure~\ref{fig:viz-measurement-prob} compares measurement outcomes (top 20 basis states) and probability distributions (top 16 states) between original and partitioned circuits using color-coded bar charts.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.75\textwidth]{docs/screenshots/components/viz_measurement_prob}}
    \caption{Measurement distribution and probability comparison}
    \label{fig:viz-measurement-prob}
\end{figure}

\subsubsection{State Vector and Density Matrix Comparisons}

Figure~\ref{fig:viz-statevector-density} shows state vector amplitudes (top 32) with phase-encoded colors and density matrix heatmaps $\rho = |\psi\rangle\langle\psi|$ with magnitude-based intensity.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.75\textwidth]{docs/screenshots/components/viz_state-vector_density}}
    \caption{State vector amplitudes and density matrix heatmaps}
    \label{fig:viz-statevector-density}
\end{figure}

\subsubsection{Entanglement Entropy Scaling}

Figure~\ref{fig:viz-entropy} plots Second Rényi entropy $S_2 = -\log_2(\text{Tr}(\rho^2))$ against subsystem size. This visualization reveals how partitioning affects quantum entanglement structure across subsystem boundaries.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/components/viz_entropy}}
    \caption{Entanglement entropy scaling}
    \label{fig:viz-entropy}
\end{figure}

All Plotly visualizations support hover tooltips, zoom/pan, legend toggles, and PNG/SVG export. State vector and density matrix views feature cross-highlighting to correlate different state representations.

\section{Advanced Features}
\label{sec:user:advanced}

\subsection{Keyboard Shortcuts}
\label{subsec:user:keyboard}

The platform provides keyboard shortcuts for efficient workflow:

\begin{table}[H]
    \centering
    \begin{tabular}{ | m{0.35\textwidth} | m{0.55\textwidth} | }
        \hline
        \textbf{Shortcut} & \textbf{Action} \\
        \hline \hline
        Ctrl/Cmd + Z & Undo last circuit modification \\
        \hline
        Ctrl/Cmd + Shift + Z & Redo previously undone action \\
        \hline
        Ctrl/Cmd + S & Save current circuit to database \\
        \hline
        Ctrl/Cmd + Enter & Execute current circuit \\
        \hline
        Delete/Backspace & Delete selected gates \\
        \hline
        Escape & Deselect all gates \\
        \hline
        Ctrl/Cmd + A & Select all gates in circuit \\
        \hline
        Ctrl/Cmd + G & Group selected gates \\
        \hline
        Shift + Click & Multi-select gates \\
        \hline
    \end{tabular}
    \caption{Keyboard shortcuts for circuit composer operations}
    \label{tab:shortcuts}
\end{table}

Shortcuts work consistently across Windows, Linux, and macOS by detecting the operating system and substituting Cmd for Ctrl on macOS.

\subsection{Dark Mode}
\label{subsec:user:darkmode}

The interface supports automatic dark mode switching based on system preferences or manual toggle via the settings menu. Dark mode adapts the circuit canvas background, gate colors, visualization schemes, and UI components for comfortable viewing in low-light environments (Figure~\ref{fig:dark-mode}). Theme preferences persist across sessions and apply immediately without page refresh.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{docs/screenshots/pages/composer_page_dark}}
    \caption{Circuit composer interface in dark mode showing adapted colors for canvas, gates, and UI components}
    \label{fig:dark-mode}
\end{figure}

\subsection{Export and Import}
\label{subsec:user:export}

Circuits can be exported in three formats: QASM 2.0 for compatibility with Qiskit and other quantum frameworks, JSON for platform-native storage with full metadata preservation, or PNG/SVG for visual documentation. The SVG export format (Figure~\ref{fig:export-svg}) produces scalable vector graphics suitable for inclusion in publications, presentations, and technical documentation without quality loss at any zoom level. Import accepts QASM 2.0 and JSON formats, with validation and error reporting for syntax issues.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.95\textwidth]{docs/screenshots/miscellaneous/partition_exported_view.png}}
    \caption{Example of circuit exported as PNG showing clean vector graphics with gates, wires, and labels}
    \label{fig:export-svg}
\end{figure}

\section{Troubleshooting}
\label{sec:user:troubleshooting}

This section addresses common issues users encounter when working with Qubitkit. Each entry follows a three-part structure: symptoms you will observe, the underlying cause, and steps to resolve the issue.

\subsection{Authentication Issues}
\label{subsec:user:troubleshoot-auth}

\textbf{Symptom:} Clicking "Sign in with Google" or "Sign in with Microsoft" redirects to authentication provider but then shows error "Authentication failed" or returns to login page without signing in.

\textbf{Cause:} Browser is blocking third-party cookies or pop-ups required by OAuth flows. Microsoft MSAL in particular requires pop-up windows for certain authentication scenarios.

\textbf{Resolution:}
\begin{enumerate}
    \item Check browser address bar for pop-up blocker icon (usually right side)
    \item Temporarily allow pop-ups for the Qubitkit domain
    \item Verify third-party cookies are enabled in browser privacy settings
    \item Clear browser cache and cookies, then retry authentication
    \item If issue persists, use email verification authentication instead
\end{enumerate}

\subsection{Connection and Performance Issues}
\label{subsec:user:troubleshoot-connection}

\textbf{Symptom:} Job monitoring panel shows "Connecting..." indefinitely, or WebSocket connection repeatedly disconnects and reconnects. Progress updates stop arriving during circuit execution.

\textbf{Cause:} Corporate firewalls or restrictive networks may block WebSocket connections on port 443. Some antivirus software also interferes with WebSocket protocols. Network instability can cause connection drops.

\textbf{Resolution:}
\begin{enumerate}
    \item Open browser developer console (F12) → Network tab → WS filter to check for WebSocket errors
    \item Verify port 443 (wss:// protocol) is not blocked by network firewall
    \item Test from different network (mobile hotspot) to isolate network versus platform issue
    \item Platform automatically retries with exponential backoff (up to 10 attempts, maximum 30s delay between attempts)
    \item Contact network administrator if issue persists on institutional network
\end{enumerate}

\subsection{Circuit Execution Problems}
\label{subsec:user:troubleshoot-execution}

\textbf{Symptom:} Circuit execution takes longer than expected, or jobs remain in "queued" status for extended periods. Backend returns timeout errors.

\textbf{Cause:} SSH connection pool may be exhausted (maximum 5 concurrent connections). Large circuits with many gates require longer processing time. Remote SQUANDER server may be under heavy load.

\textbf{Resolution:}
\begin{enumerate}
    \item Check job monitoring panel for current phase—execution may be progressing slowly rather than stalled
    \item Wait for other users' jobs to complete if connection pool is saturated
    \item Simplify circuit design to reduce gate count and qubit usage
    \item Verify network connection quality is stable for WebSocket streaming
    \item Check backend logs for SSH connection errors or timeout messages
\end{enumerate}

\subsection{Data Persistence Issues}
\label{subsec:user:troubleshoot-persistence}

\textbf{Symptom:} Undo history disappears after page refresh. Circuits fail to save or show outdated content after reload. Browser shows "Storage quota exceeded" warnings.

\textbf{Cause:} Undo history stores in localStorage with 5MB quota per domain. If quota is exceeded, browser may clear localStorage. Network interruptions during save operations can cause data loss.

\textbf{Resolution:}
\begin{enumerate}
    \item Save important circuits to MongoDB database regularly via Ctrl+S (Cmd+S on macOS)
    \item Clear localStorage for other domains to free up quota
    \item Check browser console for quota exceeded errors
    \item Reduce undo history depth by manually clearing old states
    \item Verify stable network connection before performing critical save operations
\end{enumerate}

\subsection{Visualization Rendering Issues}
\label{subsec:user:troubleshoot-visualization}

\textbf{Symptom:} Visualization panel shows blank space or "Loading..." indefinitely. Charts render incompletely with missing data series. Browser console shows JavaScript errors related to Plotly or D3.

\textbf{Cause:} Browser lacks WebGL support required for Plotly 3D visualizations. Browser extensions may interfere with dynamic content rendering. Large state vectors exceed rendering performance limits.

\textbf{Resolution:}
\begin{enumerate}
    \item Verify browser supports WebGL by visiting \texttt{get.webgl.org}
    \item Temporarily disable browser extensions that modify page content
    \item Check browser console (F12) for JavaScript errors and error stack traces
    \item Try different visualization type if specific chart fails to render
    \item Update browser to latest version for improved graphics performance
    \item Reduce circuit size if state vector visualization is too large to render
\end{enumerate}

\subsection{QASM Import and Export Issues}
\label{subsec:user:troubleshoot-qasm}

\textbf{Symptom:} QASM import shows syntax error messages. Exported QASM fails to parse in external tools. Gates appear with incorrect parameters after import.

\textbf{Cause:} Platform supports OpenQASM 2.0 specification; QASM 3.0 features are not supported. Custom gate definitions may be missing. Parameter format mismatches between tools.

\textbf{Resolution:}
\begin{enumerate}
    \item Verify QASM syntax using external validators before import
    \item Check that all gate definitions exist in \texttt{qelib1.inc} include file
    \item Review error messages for specific line numbers and syntax issues
    \item Ensure custom gates are defined before use in circuit
    \item Convert QASM 3.0 code to 2.0 specification if using newer syntax
    \item Export circuit as JSON format for platform-native serialization
\end{enumerate}

\subsection{Reporting Unresolved Issues}
\label{subsec:user:troubleshoot-reporting}

For issues not resolved through the above troubleshooting steps, users can report bugs via the feedback form accessible from the help menu. Effective bug reports should include:

\begin{compactitem}
    \item Browser name and version (e.g., Chrome 120.0.6099.109)
    \item Operating system and version (e.g., macOS 14.2, Windows 11)
    \item Complete error messages from browser console (F12 → Console tab)
    \item Steps to reproduce the issue from a clean state
    \item Screenshots or screen recordings demonstrating the problem
    \item Circuit QASM code if issue relates to specific circuit behavior
\end{compactitem}

The development team monitors bug reports and typically responds within 48 hours. Include your email address if you would like to receive updates on issue resolution.