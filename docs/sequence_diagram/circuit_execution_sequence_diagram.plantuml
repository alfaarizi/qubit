@startuml circuit_execution_sequence_diagram

!define BACKEND_COLOR #E1F5FF
!define FRONTEND_COLOR #FFF3E0

skinparam style strictuml
skinparam actorBackgroundColor #FFFFFF
skinparam actorBorderColor #000000
skinparam scale 0.5
skinparam sequenceMessageAlign center
skinparam defaultFontName serif
skinparam defaultFontSize 10

' === participants ===
actor "User" as User
participant "CircuitToolbar\n<<component>>" as Toolbar
participant "CircuitStore\n<<context>>" as CStore
participant "circuitsAPI\n<<service>>" as CircuitsAPI
participant "apiClient\n<<service>>" as ApiClient
box Backend BACKEND_COLOR
participant "circuits Endpoints\n<<controller>>" as APIEndpoints
participant "PartitionService\n<<service>>" as PartitionSvc
participant "SimulationService\n<<service>>" as SimSvc
participant "jobStore\n<<internal>>" as JobStoreBackend
participant "WebSocketManager\n<<service>>" as WSManager
end box
participant "WebSocket\n<<protocol>>" as WS
participant "jobStore\n<<store>>" as JobStoreFrontend
participant "ResultsPanel\n<<component>>" as ResultsPanel

== Initiate Execution ==

alt run partition (execute circuit)
    User -> Toolbar: select strategy, backend,\nmax size, click "execute"
    activate Toolbar
    
    note right of User: partition and simulation workflow
    
    Toolbar -> Toolbar: prepare request
    activate Toolbar
    deactivate Toolbar
    
else import QASM
    User -> Toolbar: upload .qasm file click "import"
    activate Toolbar
    
    note right of User: parse QASM and render circuit workflow
    
    Toolbar -> Toolbar: read file
    activate Toolbar
    deactivate Toolbar
end

Toolbar -> CStore: get circuit state\n(numQubits, gates, measurements)
activate CStore

CStore --> Toolbar: return state
deactivate CStore

== API request ==

alt partition
    Toolbar -> CircuitsAPI: partition(circuitId, circuitData, options, strategy)
    activate CircuitsAPI
    
    note right of CircuitsAPI: serialize gates for API\ninclude strategy options
    
    CircuitsAPI -> ApiClient: post(/circuits/{id}/partition,\nrequest payload)
    activate ApiClient
    
else import QASM
    Toolbar -> CircuitsAPI: importQasm(circuitId, qasmCode, options)
    activate CircuitsAPI
    
    note right of CircuitsAPI: qasm code already loaded\nfrom file
    
    CircuitsAPI -> ApiClient: post(/circuits/{id}/import-qasm,\n{qasm_code, options})
    activate ApiClient
end

note right of ApiClient: include JWT token in header

ApiClient -> APIEndpoints: HTTP POST request
activate APIEndpoints

== Backend Processing ==

APIEndpoints -> APIEndpoints: validate request\nand authenticate
activate APIEndpoints

deactivate APIEndpoints

APIEndpoints -> JobStoreBackend: create new job\n(circuitId, jobType)
activate JobStoreBackend

JobStoreBackend -> JobStoreBackend: allocate job_id\nset status = pending
activate JobStoreBackend

deactivate JobStoreBackend
deactivate JobStoreBackend

alt partition
    APIEndpoints -> PartitionSvc: enqueue(job_id,\ncircuit, strategy, options)
    activate PartitionSvc
    
    note right of APIEndpoints: start async partition task
    
    deactivate PartitionSvc
    
else import QASM
    APIEndpoints -> PartitionSvc: enqueue(job_id,\nqasm_code, options)
    activate PartitionSvc
    
    note right of APIEndpoints: parse QASM and start task
    
    deactivate PartitionSvc
end

APIEndpoints --> ApiClient: HTTP 202 Accepted\n{job_id}
deactivate APIEndpoints

note right of APIEndpoints: returns immediately\nfor async processing

== Frontend Response ==

ApiClient --> CircuitsAPI: response
deactivate ApiClient
deactivate ApiClient

CircuitsAPI -> JobStoreFrontend: enqueueJob(job_id, circuitId, jobType: 'partition'/'import')
activate JobStoreFrontend

CircuitsAPI --> Toolbar: return job_id
deactivate CircuitsAPI
deactivate CircuitsAPI

Toolbar -> Toolbar: setIsExecuting(true)\nshow progress bar
activate Toolbar

note right of Toolbar: immediate UI feedback\njob runs in background

deactivate Toolbar

== Asynchronous Execution ==

opt execution in background (asynchronous)
    loop while job is executing
        group backend execution
            PartitionSvc -> PartitionSvc: process partition\nupdate phase & progress
            activate PartitionSvc
            
            PartitionSvc -> JobStoreBackend: addUpdate(job_id,\nphase_update)
            deactivate PartitionSvc
            activate JobStoreBackend
            
            note right of PartitionSvc: job status being\nconstantly updated
            
            JobStoreBackend -> WSManager: broadcast(job_id,\nphase message)
            deactivate JobStoreBackend
            activate WSManager
            
            note right of JobStoreBackend: message includes phase,\nprogress %, timestamp
            
            WSManager -> WS: send message to room
            deactivate WSManager
            activate WS
            
            note right of WSManager: sends only to clients\nin job room
        end
        
        group frontend receiving
            WS -> WS: propagate to connected clients
            activate WS
            
            WS -> JobStoreFrontend: message received
            activate JobStoreFrontend
            deactivate WS

            JobStoreFrontend -> JobStoreFrontend: addUpdate(job_id, update)
            activate JobStoreFrontend
            deactivate WS
            
            note right of JobStoreFrontend: updates store subscribers
            
            deactivate JobStoreFrontend
            deactivate JobStoreFrontend
            
            Toolbar -> JobStoreFrontend: query job status
            activate Toolbar
            
            JobStoreFrontend --> Toolbar: return progress & status
            deactivate JobStoreFrontend
            
            Toolbar -> Toolbar: update progress display
            activate Toolbar
            
            deactivate Toolbar
            deactivate Toolbar
        end
    end
    
    group job completion
        activate JobStoreBackend
        
        alt partition successful
            PartitionSvc -> SimSvc: simulate(partitions)
            activate PartitionSvc
            activate SimSvc
            
            SimSvc -> SimSvc: execute quantum simulation
            activate SimSvc
            deactivate SimSvc
            
            SimSvc -> PartitionSvc: deserialize results
            deactivate SimSvc
            
            PartitionSvc -> JobStoreBackend: completeJob(job_id,\nresults: SimulationResults)
            activate JobStoreBackend

        else import QASM successful
            PartitionSvc -> PartitionSvc: deserialize gates\nfrom QASM
            
            PartitionSvc -> SimSvc: simulate(gates,\nmeasurements)
            activate SimSvc
            
            SimSvc -> SimSvc: execute quantum simulation
            activate SimSvc
            deactivate SimSvc
            deactivate SimSvc
            
            PartitionSvc -> JobStoreBackend: completeJob(job_id,\nresults: SimulationResults)
            
        else execution error
            PartitionSvc -> JobStoreBackend: setJobError(job_id, error)
            deactivate PartitionSvc
            deactivate PartitionSvc
        end
        
    end
    deactivate JobStoreFrontend
end

== Results Display ==

JobStoreBackend -> WSManager: broadcast(job_id,\ncomplete message with results)
deactivate JobStoreBackend
activate WSManager

note right of JobStoreBackend: final message includes\nresults or error info

deactivate WSManager

WSManager -> WS: send completion message
deactivate WSManager
activate WS

WS --> JobStoreFrontend: receive complete
deactivate WS
activate  JobStoreFrontend

JobStoreFrontend -> JobStoreFrontend: completeJob(job_id)
activate JobStoreFrontend

JobStoreFrontend -> JobStoreFrontend: setResults(circuitId, results)
activate JobStoreFrontend

Toolbar -> JobStoreFrontend: query final job
activate Toolbar

JobStoreFrontend --> Toolbar: job complete with results
deactivate JobStoreFrontend
deactivate JobStoreFrontend

Toolbar -> Toolbar: setIsExecuting(false)\nhide progress bar
activate Toolbar

deactivate Toolbar
deactivate Toolbar
deactivate Toolbar
deactivate Toolbar

alt partition results
    ResultsPanel -> JobStoreFrontend: getResults(circuitId)
    activate ResultsPanel
    
    JobStoreFrontend --> ResultsPanel: return results
    
    ResultsPanel <- ResultsPanel: render visualizations\n(BlochSphere, Histogram, etc.)
    activate ResultsPanel
    
    note left of ResultsPanel: display partition info\nand quantum state
    
    deactivate ResultsPanel
    deactivate ResultsPanel
    
else import QASM results
    CircuitCanvas -> JobStoreFrontend: getResults(circuitId)
    activate CircuitCanvas
    
    JobStoreFrontend --> CircuitCanvas: return results
    
    CircuitCanvas <- CircuitCanvas: useCircuitRenderer()
    activate CircuitCanvas
    
    note left of CircuitCanvas: re-render with\nimported gates
    
    deactivate JobStoreFrontend
    deactivate CircuitCanvas
    deactivate CircuitCanvas
end


note over User, ResultsPanel
    execution completed: user initiated either partition (with strategy selection) or import QASM,\nbackend processed gates and ran simulation, frontend received updates via WebSocket and displayed results
end note

@enduml
